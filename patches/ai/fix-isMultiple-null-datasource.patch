diff --git a/src/Base/AiVdbProviderClientBase.php b/src/Base/AiVdbProviderClientBase.php
--- a/src/Base/AiVdbProviderClientBase.php
+++ b/src/Base/AiVdbProviderClientBase.php
@@ -424,12 +424,27 @@ abstract class AiVdbProviderClientBase implements AiVdbProviderInterface, AiVdbP
    */
   public function isMultiple(FieldInterface $field): bool {
     [$fieldName] = explode(':', $field->getPropertyPath());
-    [, $entity_type] = explode(':', $field->getDatasourceId());
-    $fields = $this->entityFieldManager->getFieldStorageDefinitions($entity_type);
-    foreach ($fields as $field) {
-      if ($field->getName() === $fieldName) {
-        $cardinality = $field->getCardinality();
+
+    // Check if datasource ID is available (computed fields like node_grants,
+    // role_access, rendered_item don't have a datasource).
+    $datasourceId = $field->getDatasourceId();
+    if ($datasourceId === NULL || !str_contains($datasourceId, ':')) {
+      // For computed/processor fields without a datasource, check if the
+      // underlying data definition indicates it's a list.
+      $dataDefinition = $field->getDataDefinition();
+      if ($dataDefinition && $dataDefinition->isList()) {
+        return TRUE;
+      }
+      // Default to single value for computed fields without list definition.
+      return FALSE;
+    }
+
+    [, $entity_type] = explode(':', $datasourceId);
+    $fields = $this->entityFieldManager->getFieldStorageDefinitions($entity_type);
+    foreach ($fields as $fieldDef) {
+      if ($fieldDef->getName() === $fieldName) {
+        $cardinality = $fieldDef->getCardinality();
         return !($cardinality === 1);
       }
     }

diff --git a/modules/ai_search/src/Plugin/EmbeddingStrategy/EmbeddingBase.php b/modules/ai_search/src/Plugin/EmbeddingStrategy/EmbeddingBase.php
--- a/modules/ai_search/src/Plugin/EmbeddingStrategy/EmbeddingBase.php
+++ b/modules/ai_search/src/Plugin/EmbeddingStrategy/EmbeddingBase.php
@@ -417,25 +417,32 @@ abstract class EmbeddingBase extends PluginBase implements EmbeddingStrategyInte
       // Do nothing, we can just index the values for this type of field.
     }
 
+    // Check if the field is a list type - if so, always return an array even
+    // for single values. This ensures array_contains() filters work correctly.
+    $definition = $field->getDataDefinition();
+    $isList = $definition && $definition->isList();
+
     // Always composite if field supports multiple. Otherwise, if the field is
     // a single value, we can choose base on the field type At some point we
     // probably need to consider what field types the Vector Database supports
     // as metadata, but for now let's assume, strings, floats, integers, and
     // boolean values are fine for all.
-    if (in_array($field->getType(), ['date', 'boolean', 'integer']) && count($values) === 1) {
+    if (!$isList && in_array($field->getType(), ['date', 'boolean', 'integer']) && count($values) === 1) {
       return (int) reset($values);
     }
-    elseif (in_array($field->getType(), ['boolean']) && count($values) === 1) {
+    elseif (!$isList && in_array($field->getType(), ['boolean']) && count($values) === 1) {
       return (bool) reset($values);
     }
-    elseif (in_array($field->getType(), ['decimal']) && count($values) === 1) {
+    elseif (!$isList && in_array($field->getType(), ['decimal']) && count($values) === 1) {
       return (float) reset($values);
     }
-    elseif (count($values) == 1) {
+    elseif (!$isList && count($values) == 1) {
       return $this->converter->convert((string) reset($values));
     }
-    elseif (count($values) > 1) {
-
+    elseif (count($values) >= 1) {
+      // For list fields or multiple values, always return an array.
       // Some Vector Databases support arrays, return that in the metadata
       // and leave it to the Provider to flatten if needed.
       $parts = [];
